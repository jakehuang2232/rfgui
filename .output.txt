diff --git a/rsx-macro/src/lib.rs b/rsx-macro/src/lib.rs
index 7938e38..58f003b 100644
--- a/rsx-macro/src/lib.rs
+++ b/rsx-macro/src/lib.rs
@@ -10,8 +10,49 @@ use syn::{

 #[proc_macro]
 pub fn rsx(input: TokenStream) -> TokenStream {
-    let root = syn::parse_macro_input!(input as ElementNode);
-    expand_element(&root).into()
+    let nodes = match syn::parse::<MultipleNodes>(input) {
+        Ok(m) => m.nodes,
+        Err(err) => return err.to_compile_error().into(),
+    };
+
+    if nodes.len() == 1 {
+        expand_node(&nodes[0]).into()
+    } else {
+        let children = nodes.iter().map(expand_node);
+        quote! {
+            ::rust_gui::ui::RsxNode::fragment(vec![
+                #(#children),*
+            ])
+        }
+        .into()
+    }
+}
+
+struct MultipleNodes {
+    nodes: Vec<Child>,
+}
+
+impl Parse for MultipleNodes {
+    fn parse(input: ParseStream) -> Result<Self> {
+        let mut nodes = Vec::new();
+        while !input.is_empty() {
+            if input.peek(Token![<]) && !input.peek2(Token![/]) {
+                nodes.push(Child::Element(input.parse()?));
+            } else if input.peek(LitStr) {
+                nodes.push(Child::TextLiteral(input.parse()?));
+            } else if input.peek(syn::token::Brace) {
+                let content;
+                braced!(content in input);
+                nodes.push(Child::Expr(content.parse()?));
+            } else {
+                let raw = parse_raw_text(input)?;
+                if !raw.is_empty() {
+                    nodes.push(Child::TextRaw(raw));
+                }
+            }
+        }
+        Ok(MultipleNodes { nodes })
+    }
 }

 #[proc_macro_attribute]
@@ -31,7 +72,25 @@ struct ElementNode {
 #[derive(Clone)]
 struct Prop {
     key: Ident,
-    value: Expr,
+    value: PropValueExpr,
+}
+
+#[derive(Clone)]
+enum PropValueExpr {
+    Expr(Expr),
+    StyleObject(Vec<StyleEntry>),
+}
+
+#[derive(Clone)]
+enum StyleValueExpr {
+    Expr(Expr),
+    StyleObject(Vec<StyleEntry>),
+}
+
+#[derive(Clone)]
+struct StyleEntry {
+    key: Ident,
+    value: StyleValueExpr,
 }

 #[derive(Clone)]
@@ -51,13 +110,23 @@ impl Parse for ElementNode {
         while !input.peek(Token![>]) && !(input.peek(Token![/]) && input.peek2(Token![>])) {
             let key: Ident = input.parse()?;
             input.parse::<Token![=]>()?;
-            let value: Expr = if input.peek(syn::token::Brace) {
+            let value: PropValueExpr = if input.peek(syn::token::Brace) {
                 let content;
                 braced!(content in input);
-                content.parse()?
+                if key == "style" && content.peek(syn::token::Brace) {
+                    let style_content;
+                    braced!(style_content in content);
+                    let entries = parse_style_entries(&style_content)?;
+                    if !content.is_empty() {
+                        return Err(syn::Error::new(content.span(), "style 物件 語法錯誤"));
+                    }
+                    PropValueExpr::StyleObject(entries)
+                } else {
+                    PropValueExpr::Expr(content.parse()?)
+                }
             } else {
                 let lit: Lit = input.parse()?;
-                parse_quote!(#lit)
+                PropValueExpr::Expr(parse_quote!(#lit))
             };
             props.push(Prop { key, value });
         }
@@ -110,6 +179,29 @@ impl Parse for ElementNode {
     }
 }

+fn parse_style_entries(input: ParseStream) -> Result<Vec<StyleEntry>> {
+    let mut entries = Vec::new();
+    while !input.is_empty() {
+        let style_key: Ident = input.parse()?;
+        input.parse::<Token![:]>()?;
+        let style_value = if style_key == "hover" && input.peek(syn::token::Brace) {
+            let nested;
+            braced!(nested in input);
+            StyleValueExpr::StyleObject(parse_style_entries(&nested)?)
+        } else {
+            StyleValueExpr::Expr(input.parse()?)
+        };
+        entries.push(StyleEntry {
+            key: style_key,
+            value: style_value,
+        });
+        if input.peek(Token![,]) {
+            input.parse::<Token![,]>()?;
+        }
+    }
+    Ok(entries)
+}
+
 fn parse_raw_text(input: ParseStream) -> Result<String> {
     let mut tokens = Vec::new();

@@ -149,7 +241,12 @@ fn expand_element(element: &ElementNode) -> proc_macro2::TokenStream {
         quote! {}
     };
     let prop_statements = element.props.iter().map(|p| expand_prop_set(tag, p));
-    let child_statements = element.children.iter().map(expand_child_push);
+    let child_statements = element.children.iter().map(|c| {
+        let child_expr = expand_node(c);
+        quote! {
+            __rsx_children.push(#child_expr);
+        }
+    });

     quote! {
         {
@@ -169,36 +266,221 @@ fn expand_element(element: &ElementNode) -> proc_macro2::TokenStream {
 fn expand_prop_set(tag: &Path, prop: &Prop) -> proc_macro2::TokenStream {
     let key_ident = &prop.key;
     let key = prop.key.to_string();
-    let value = &prop.value;
+    let value_tokens = match &prop.value {
+        PropValueExpr::Expr(value) => {
+            quote! {
+                __rsx_props.push(#key, ::rust_gui::ui::IntoPropValue::into_prop_value(#value));
+            }
+        }
+        PropValueExpr::StyleObject(entries) => {
+            let style_inserts = entries.iter().map(expand_style_entry);
+            quote! {
+                let mut __rsx_style = ::rust_gui::Style::new();
+                #(#style_inserts)*
+                __rsx_props.push(#key, ::rust_gui::ui::IntoPropValue::into_prop_value(__rsx_style));
+            }
+        }
+    };
     quote! {
         let _ = |__schema: &<#tag as ::rust_gui::ui::RsxPropSchema>::PropsSchema| {
             let _ = &__schema.#key_ident;
         };
-        __rsx_props.push(#key, ::rust_gui::ui::IntoPropValue::into_prop_value(#value));
+        #value_tokens
     }
 }

-fn expand_child_push(child: &Child) -> proc_macro2::TokenStream {
-    match child {
-        Child::Element(element) => {
-            let child_expr = expand_element(element);
-            quote! {
-                __rsx_children.push(#child_expr);
+fn expand_style_entry(entry: &StyleEntry) -> proc_macro2::TokenStream {
+    let key_ident = &entry.key;
+    let key = entry.key.to_string();
+    let style_value_tokens = match key.as_str() {
+        "border" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! { __rsx_style.set_border(#value); },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.border 需要表達式值");
+            },
+        },
+        "background" | "background_color" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::BackgroundColor,
+                    ::rust_gui::ParsedValue::Color(
+                        ::rust_gui::IntoColor::<::rust_gui::Color>::into_color(#value)
+                    ),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.background 需要表達式值");
+            },
+        },
+        "border_radius" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.set_border_radius(::rust_gui::IntoBorderRadius::into_border_radius(#value));
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.border_radius 需要表達式值");
+            },
+        },
+        "opacity" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::Opacity,
+                    ::rust_gui::ParsedValue::Opacity(::rust_gui::Opacity::new((#value) as f32)),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.opacity 需要表達式值");
+            },
+        },
+        "padding" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! { __rsx_style.set_padding(#value); },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.padding 需要表達式值");
+            },
+        },
+        "width" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::Width,
+                    ::rust_gui::ParsedValue::Length(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.width 需要表達式值");
+            },
+        },
+        "height" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::Height,
+                    ::rust_gui::ParsedValue::Length(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.height 需要表達式值");
+            },
+        },
+        "display" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::Display,
+                    ::rust_gui::ParsedValue::Display(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.display 需要表達式值");
+            },
+        },
+        "flex_direction" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::FlexDirection,
+                    ::rust_gui::ParsedValue::FlexDirection(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.flex_direction 需要表達式值");
+            },
+        },
+        "flex_wrap" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::FlexWrap,
+                    ::rust_gui::ParsedValue::FlexWrap(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.flex_wrap 需要表達式值");
+            },
+        },
+        "justify_content" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::JustifyContent,
+                    ::rust_gui::ParsedValue::JustifyContent(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.justify_content 需要表達式值");
+            },
+        },
+        "align_items" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::AlignItems,
+                    ::rust_gui::ParsedValue::AlignItems(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.align_items 需要表達式值");
+            },
+        },
+        "gap" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::Gap,
+                    ::rust_gui::ParsedValue::Length(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.gap 需要表達式值");
+            },
+        },
+        "scroll_direction" => match &entry.value {
+            StyleValueExpr::Expr(value) => quote! {
+                __rsx_style.insert(
+                    ::rust_gui::PropertyId::ScrollDirection,
+                    ::rust_gui::ParsedValue::ScrollDirection(#value),
+                );
+            },
+            StyleValueExpr::StyleObject(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.scroll_direction 需要表達式值");
+            },
+        },
+        "hover" => match &entry.value {
+            StyleValueExpr::StyleObject(entries) => {
+                let hover_inserts = entries.iter().map(expand_style_entry);
+                quote! {
+                    let mut __rsx_hover_style = ::rust_gui::Style::new();
+                    {
+                        let __rsx_style = &mut __rsx_hover_style;
+                        #(#hover_inserts)*
+                    }
+                    __rsx_style.set_hover(__rsx_hover_style);
+                }
             }
-        }
+            StyleValueExpr::Expr(_) => quote_spanned! {entry.key.span()=>
+                compile_error!("style.hover 需要物件語法，例如 hover: {{ background: \"#fff\" }}");
+            },
+        },
+        _ => quote_spanned! {entry.key.span()=>
+            compile_error!("不支援的 style key");
+        },
+    };
+
+    quote! {
+        let _ = |__style_schema: &::rust_gui::ui::host::ElementStylePropSchema| {
+            let _ = &__style_schema.#key_ident;
+        };
+        #style_value_tokens
+    }
+}
+
+fn expand_node(child: &Child) -> proc_macro2::TokenStream {
+    match child {
+        Child::Element(element) => expand_element(element),
         Child::TextLiteral(text) => {
             quote! {
-                __rsx_children.push(::rust_gui::ui::RsxNode::text(#text));
+                ::rust_gui::ui::RsxNode::text(#text)
             }
         }
         Child::TextRaw(text) => {
             quote! {
-                __rsx_children.push(::rust_gui::ui::RsxNode::text(#text));
+                ::rust_gui::ui::RsxNode::text(#text)
             }
         }
         Child::Expr(expr) => {
             quote! {
-                __rsx_children.push(::rust_gui::ui::IntoRsxNode::into_rsx_node(#expr));
+                ::rust_gui::ui::IntoRsxNode::into_rsx_node(#expr)
             }
         }
     }
